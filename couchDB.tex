\section{Aufbau der SumoViz-Anwendung}

Die entwickelte Software \emph{SumoViz3D} ermöglicht die browserbasierte dreidimensionale Darstellung von Fußgängersimulationsdaten. Diese Arbeit basiert auf der von Mustafa K. Isik entwickelten Anwendung \emph{SumoViz}, die eine einfache Visualisierung in 2D zeigte. Für SumoViz3D wird die bestehende serverseitige Architektur den Anforderungen entsprechend erweitert und die Client-Seite von Grund auf neu entwickelt.
\begin{figure}[h]
\includegraphics[width=\textwidth]{media/tec-stack.pdf}
\caption{Struktureller Aufbau von SumoViz3D}
\label{tecstack}
\end{figure}
Die SumoViz-Anwendung läuft als Client-Server-Applikation (vgl. Abbildung \ref{tecstack}), bei der die Daten serverseitig gespeichert und aufbereitet werden. Die Berechnung der Darstellung erfolgt komplett im Browser. Grundlage der Visualisierung sind Textdateien die serverseitig geparst und dann in einer CouchDB-Datenbank abgelegt werden. Ein node.js-Webserver liefert entsprechend der Anfrage vom Client die Daten für die Darstellung aus. Die Darstellung erfolgt dann mittels HTML5 und WebGL im Browser. Im Vergleich zu SumoViz wurden für SumoViz3D der clientseitige Teil komplett neu geschrieben und Anpassungen an den serverseitigen Komponenten vorgenommen. 


\section{Serverkomponenten: CouchDB und node.js} 
Apache CouchDB ist ein Datenbanksystem der \emph{Apache Software Foundation} das einen dokumentenorientieren Ansatz einsetzt. Im Gegensatz zu relationalen Datenbanken wird bei dokumentenorientieren Datenbanken kein festes Schema vorgegeben in dem die Datensätze abgelegt werden. Stattdessen wird jeder Datensatz als Dokument mit beliebiger eigener Struktur in der Datenbank abgelegt. Jedes Dokument ist als JSON-Objekt repräsentiert und hat mindestens ein Feld \verb+_id+ zur Identifikation. Der Zugriff auf die Daten erfolgt per HTTP-REST-Schnittstelle. Das bedeutet der Aufruf einer bestimmten URL liefert per HTTP die angeforderten Datensätze zurück. Über das HTTP-POST-Kommando können Daten in die Datenbank eingefügt werden.

Abfragen von einzelnen oder mehreren Datensätzen werden \emph{Views} genannt. Views können in so geannten \emph{Design documents} gespeichert werden und sind dann für die Abfrage per HTTP-Request verfügbar. CouchDB speichert die einzelnen Views zwischen, damit diese schneller verfügbar sind. Zur Realisierung von Filtern und gezielten Abfragen verwendet CouchDB das \emph{MapReduce}-Verfahren, bei dem auf den Datenbestand nacheinander erst ein \emph{map}- und dann ein \emph{reduce}-Schritt ausgeführt wird. Diese Schritte werden durch JavaScript-Funktionen beschrieben und können komplexe Aufgaben auf den Daten ausführen. Solange der Datenbestand sich nicht verändert hat, muss das Ergebnis des MapReduce nicht neu berechnet werden. Der map-Schritt wird für jedes Dokument der Datenbank ausgeführt und transformiert es in eine neue Struktur. Als Rückgabe wird pro Datensatz kein, ein, oder mehrere Key-Value-Paare erwartet, die mittels \verb+emit(key,value)+ ausgegeben werden. Zusätzlich können hier mittels if-Abfragen Filter implementiert werden.

Der reduce-Schritt ist optional und wird auf dem Zwischenergebnis des map-Schritts ausgeführt. Als Parameter wird ein Array mit den Keys und ein Array mit den Values des map-Schritts übergeben. Bei großen Datensätzen wird die reduce-Funktion für einzelne Abschnitte des Zwischenergebnisses aufgerufen, anschließend nochmal für die bereits reduzierten Zwischenergebnisse. Deshalb wird noch der Parameter \verb+rereduce+ übergeben, der mitteilt, ob es sich um einen bereits reduzierten Datensatz handelt.

% http://www.slideshare.net/okurow/couchdb-mapreduce-13321353
% MapReduce Views in CouchDB, Bradley Holt, O’Reilly, 2011 

Die zweite serverseitige Komponente ist \emph{node.js}, das aus Googles \emph{V8} JavaScript-Engine und einigen weiteren Komponenten besteht und damit die serverseitige Ausführung von JavaScript-Code ermöglicht. Node.js ist sehr leistungsfähig, da der JavaScript-Code vor der Ausführung in Maschinensprache übersetzt wird. Die Einbindung zusätzlicher Komponenten ist bei node.js über Module möglich, die über den Paketmanager \emph{npm (Node Packaged Modules)} installiert werden können. Auf Serverseite von SumoViz wird node.js für das Importieren (\verb+dataimport.js+) und Ausliefern (\verb+app.js+) der Daten eingesetzt.

\subsection{Importieren der Simulationsdaten}

Die Ergebnisse der Simulation werden in eine Textdatei geschrieben, die zur Verwendung mit SumoViz eingelesen und in der Datenbank abgelegt wird. Die Datensätze sind zeilenweise in der Ausgangsdatei abgelegt und in Blöcke unterteilt. Blöcke innerhalb der Datei werden mit \verb+Begin+ und \verb+End+ sowie dem Blocknamen gekennzeichnet. Beispielsweise sind die Daten der Baugeometrie im Block \verb+Begin geometry+ angelegt. Die Ausgangsdatei enthält immer einen Block mit Parametern zur Simulation, die in SumoViz nicht verwendet werden, da die Parameter hauptsächlich für die Erstellung der Simulation, nicht aber für die Visualisierung nötig sind.

Zum Importieren der Daten in die \emph{CouchDB}-Datenbank exsistiert das node.js-Skript \verb+dataimport.js+, das die Datei block- und zeilenweise verarbeitet und die Daten dann in der Datenbank ablegt. Das Skript verarbeitet nur die Blöcke \verb+Geometry+, \verb+Data+ und \verb+Group Data+, alle anderen Inhalte der Ausgangsdatei werden ignoriert. Für die Verbindung zur CouchDB wird das Modul \emph{cradle} verwendet. Zunächst legt das Skript ein JSON-Array mit allen einzufügenden Datensätzen an, dieses wird dann mittels \emph{bulk insertion} in die Datenbank geschrieben. 



\subsubsection{Import der Fußgängerdaten}

Durch Zeilen mit den Schlüsselwörtern \verb+Begin Data+ und \verb+End Data+ ist innerhalb der Ausgabedatei ein Abschnitt mit den Fußgängerpositionsdaten ausgezeichnet. Die Datensätze enthalten einen Zeitstempel, eine Identifikationsnummer des Fußgängers, Positionsdaten und Angaben zur Ebene auf der sich der Fußgänger befindet sowie zur Dichte. Pro Zeitpunkt und sichtbaren Fußgänger wird eine Zeile in der Ausgabedatei generiert. Die Werte des Datensatzes sind mit Leerzeichen getrennt und haben folgenden Aufbau.
\begin{table}[h]
\centering
\begin{tabular}{l||l|l|l|l|l|l|l}
& \textbf{timecode} & \textbf{pedid} & \textbf{x} & \textbf{y} & \textbf{z} & \textbf{level} & \textbf{density} \\
\hline
\hline
\textbf{Datentyp} & \verb+float+ & \verb+int+ & \verb+float+ & \verb+float+ & \verb+float+ & \verb+int+ & \verb+float+ \\
\hline
\textbf{Beispiel} & \verb+14.02+ & \verb+32+ & \verb+30.06+ & \verb+36.04+ & \verb+0.00+ & \verb+0+ & \verb+0.17+ \\
\end{tabular}
\label{tbl:tablelabel}
\caption{Fußgängerdatenformat}
\end{table}

\subsubsection{Import der Geometrie}

Der Block \verb+Geometry+ enthält eine Gliederung in unterschiedliche Stockwerke, gekennzeichnet mit \verb+begin floor+, gefolgt von einer Höhenangabe zum jeweiligen Stockwerk. SumoViz und SumoViz3D unterstützen die Darstellung von Stockwerken nicht und ignorieren diese Daten deshalb. Dann folgen zeilenweise die einzelnen geometrischen Objekte. Beim Import werden nur Datensätze im Format \verb+Polygon+ importiert. Es gibt zum Beispiel noch den Typ \verb+Image+ mit dem Grafiken über die Szene gelegt werden können. Dieser wird aber nicht unterstützt und daher ebenfalls ignoriert.

Ein Polygon besteht aus einer beliebigen Anzahl Koordinatenpaare $(x_i,y_i)$, die jeweils einen Eckpunkt des Polygons darstellen. Daher sollte die Mindestzahl an Eckpunkten $3$ sein. Eine Höhenangabe ist optional, wird aber von einigen Geometrietypen beim rendern erwartet (vgl. Kapitel \ref{geo}).


\begin{table}[h]
\centering
\begin{tabular}{l||l|l|l|l|l|l|l}
& \textbf{format} & \textbf{x}$_0$ & \textbf{y}$_0$ &  \textbf{\ldots} & \textbf{name} & \textbf{type} & \textbf{height}\footnotemark \\
\hline
\hline
\textbf{Datentyp} & \verb+String+ & \verb+float+ & \verb+float+ &  \ldots & \verb+String+ & \verb+String+ & \verb+float+ \\
\hline
\textbf{Beispiel} & \verb+Polygon+ & \verb+40.39+ & \verb+42.69+ &  \ldots & \verb+o2+ & \verb+obstacle+ & \verb+3.5+ \\
\end{tabular}
\label{tbl:tablelabel}
\caption{Geometriedatenformat}
\end{table}
\footnotetext{optional}

\subsubsection{Import der Gruppendaten}

Für die Visualisierung der Gruppen in SumoViz3D wurde der Import für Gruppendaten im \verb+dataimport.js+-Skript hinzugefügt. Gruppendaten sind nicht in allen Ausgabedateien angelegt, falls sie vorhanden sind ist der Block entsprechend mit \verb+Group Data+ gekennzeichnet und in der Visualisierung steht die Einfärbung nach Gruppen zur Verfügung (siehe Kapitel \ref{colorgroups}). Ein Datensatz beinhaltet die Zugehörigkeit eines Fußgängers zu einer Gruppe. Einzelne Gruppen werden dabei implizit durch die Verwendung der jeweiligen Gruppen-ID erzeugt. Zusätzlich ist noch die Gruppengröße mit angegeben. Dieser Wert ist aber redundant, da die Gruppengröße auch mittels Summenfunktion berechnet werden kann und wird deshalb nicht mit importiert.

\begin{table}[h]
\centering
\begin{tabular}{l||l|l|l}
& \textbf{pedid} & \textbf{groupid} & \textbf{size} \\
\hline
\hline
\textbf{Datentyp} & \verb+int+ & \verb+int+ & \verb+int+ \\
\hline
\textbf{Beispiel} & \verb+241+ & \verb+32+ & \verb+3+  \\
\end{tabular}
\label{tbl:tablelabel}
\caption{Fußgängerdatenformat}
\end{table}



\subsection{Ausgabe der Simulationsdaten}

Alle Daten der Visualisierung muss der Client vom Server nachladen. Dabei handelt es sich um den Namen der Animation, Positionsdaten der Fußgänger, die bauliche Geometrie und die Gruppendaten. Jede dieser Abfragen hat eine eigene URL als Endpunkt. Node.js agiert als Webserver, verarbeitet die Anfragen und liefert entsprechend die Daten aus CouchDB aus. Die Aufbereitung der Daten findet ausschließlich in der Datenbank mittels der MapReduce-Funktionen statt. Nach dem Laden der Daten im JSON-Format werden diese im Client geparst und stehen dann als JavaScript-Objekt zur Verfügung.

\subsubsection{Ausgabe der Fußgängerdaten}

Für SumoViz wurden lediglich die x-y-Koordinaten der Fußgänger nach Zeitpunkt gruppiert und als JSON-Array ausgegeben. Die Visualisierung in SumoViz3D benötigt aber noch weitere Daten, weshalb das Datenformat umstrukturiert und erweitert werden musste. Die Fußgänger-ID (\verb+pedid+) ist notwendig um die Gruppenzuordnung zu erhalten und  die Positionsdaten eines Fußgängers zu früheren oder späteren Zeitpunkten zu bestimmen. Das ist für die Bestimmung der Geschwindigkeit und Bewegungsrichtung notwendig und kann bei zukünftigen Erweiterungen wie dem Tracing einzelner Fußgänger nützlich sein (vgl. Kapitel \ref{erweiterungen}). Zusätzlich wird noch die Dichte (\verb+density+) pro Fußgänger pro Zeitpunkt ausgeliefert. Diese Daten waren auch bisher schon gespeichert und wurden nur noch nicht mitausgeliefert. Das Format der Dokumente in CouchDB bleibt unverändert und bestehende Datensätze müssen nicht neu importiert werden. Lediglich die MapReduce-Funktionen der Design Documents wurden angepasst.


Die map-Funktion von SumoViz wurde nur geringfügig erweitert, so dass im Value-Array nun neben der Position auch die ID und die Dichte ausgegeben werden. 
\begin{lstlisting}[caption=CouchDB map-Funktion für Fußgängerdaten]
function(doc) {
    if (doc.pedid !== undefined) {
        emit(doc.time, [doc.x,doc.y,doc.density,doc.pedid]);
    }
}
\end{lstlisting}
Die ausgegebenen Key-Value-Paare werden mit einer neuen reduce-Funktion gruppiert. Die Werte werden nicht mehr in einer Array gespeichert sondern in einem Objekt pro Zeitpunkt. In diesem Objekt wird für jeden Fußgänger eine \emph{property} mit entsprechender Fußgänger-ID als Schlüssel und einem Array aus Positions- und Dichtedaten als Value angelegt. Das ermöglicht den direkten Zugriff auf Daten einer bestimmten Fußgänger-ID mit dem Aufruf \verb+pedestrianData[zeitpunkt][id]+ ohne die Anwendung einer linearen Suche durch alle Werte des Zeitpunktes nach der gesuchten ID.

Wird die Bearbeitung der Daten auf Grund der Größe aufgeteilt, so bekommt die reduce-Funktion im rereduce-Fall ein Array aus Objekten, die je einen Teil der Fußgängerdaten des jeweiligen Zeitpunkts enthalten. Dieses Array mit Objekten wird zu einem einzelnen Objekt zusammengefügt und ergibt dann das fertig Objekt für den entsprechenden Zeitpunkt.
\begin{lstlisting}[caption=CouchDB reduce-Funktion für Fußgängerdaten]
function(keys, values, rereduce) {
    if(rereduce) {
        for (i=1;i<values.length;i++) {
                for (var key in values[i]) {
                    values[0][key] = values[i][key];
                }
            }
        return values[0];
    } else {
        var sortedValues = {};
        for(var i = 0; i < values.length; i++) {
            sortedValues[values[i][3]] = 
                            [values[i][0],values[i][1],values[i][2]];
        }
        return sortedValues;
    }
}
\end{lstlisting}

Ein beispielhaftes Objekt der Fußgängerdaten für einen bestimmten Zeitpunkt der Simulation kann wie folgt aussehen:
\begin{verbatim}
    {"0":[40.23,40.05,0],"1":[40.69,37.64,0],"2":[40.92,36.44,0],...}
\end{verbatim}

\subsubsection{Ausgabe der Geometrie- und Gruppendaten}

Die Ausgabe der Geometriedaten benötigt keine Gruppierung und dementsprechend nur eine map-Funktion. Pro Geoemetrie-Objekt wird ein JSON-Objekt ausgegeben, dass die x-y-Koordinaten in Form eines Arrays und Typ, Name und Höhe als Properties darstellt. Ein entsprechendes JSON-Objekt kann zum Beispiel so aussehen:

\begin{verbatim}
    {geometry: [[64.42, 33.3], [65.42, 33.3], ...],
            "height": 3.5, "name": "plant0", "type": "obstacle"}
\end{verbatim}

Das Ursprungsformat der Gruppendaten wird nach dem Key, der Gruppen-ID gruppiert. Pro Gruppen-ID wird dann ein Array mit den in der Gruppe enthaltenen Fußgänger-IDs ausgegeben. Die reduce-Funktion muss lediglich das values-Array ausgeben, bzw. im rereduce-Fall müssen die einzelnen value-Arrays zu einem einzigen Array verbunden werden. Die Gruppen-ID wird für die Darstellung im Client nicht mehr benötigt.

\begin{lstlisting}[caption=CouchDB reduce-Funktion für Gruppendaten]
function (keys,values,rereduce) {
    if (!rereduce) return values;
    else {
        for (i=1;i<values.length;i++) values[0].concat(values[i]);
        return values[0];
    }
}
\end{lstlisting}


\section{Clientseitige Entwicklung von SumoViz3D}

Clientseitig verwendet SumoViz3D die THREE.js-Bibliothek um die Simulationsdaten in WebGL darzustellen. Mit der JavaScript-Bibliothek \emph{jQuery UI}, HTML und CSS wird die Bedienoberfläche erstellt.

\subsection{Das Interface von SumoViz3D}
Das canvas-Element zur Darstellung der Simulation wird in der vollen Browsergröße dargestellt, alle anderen Elemente werden als Overlay aus HTML-Elementen gestaltet. Dabei werden viele Bestandteile mittels jQuery UI umgesetzt. Dieses JavaScript-Framework macht es möglich Interface-Elemente wie Buttons und Dialogboxen einfach und cross-browserkompatibel anzulegen.

Die Toolbar (Abbildung \ref{screenshot} \circled{1}) ermöglicht die Steuerung des Ablaufs der Animation. Mit dem Play/Pause-Button kann die Animation abgespielt und angehalten werden. Der aktuelle Stand der Visualisierung kann mittels des Sliders verändert werden. Zusätzlich wird noch angezeigt, welcher Simulationsschritt aktuell dargestellt wird. Über die Pfeil-Buttons lässt sich schrittweise durch die Simulation navigieren. Über den Einstellungs-Button wird ein Dialog aufgerufen, über den globale Modifikationen an der Szene vorgenommen werden können (Abbildung \ref{screenshot} \circled{2}). Zusätzlich lassen sich durch einen Kontextklick auf die Geometrieobjekte die objektbezogenen Modifikationen aufrufen (Abbildung \ref{screenshot} \circled{3}).

Die THREE.js-Erweiterung \emph{Stats} (Abbildung \ref{screenshot} \circled{4}) zeigt die aktuelle Framerate mit der die Szene gezeichnet wird. Dazu wird im Aufruf der Zeichenmethode (siehe Kapitel \ref{raf}) zusätzlich noch ein Aufruf von \verb+stats.update()+ platziert, der dann die Zeit zwischen dem aktuellen Aufruf und dem letzten bestimmt und so die Framerate errechnet. Durch einen Klick auf das Modul lässt sich auch die benötigte Ausführungszeit der Zeichenmethode in Millisekunden anzeigen. In Klammern sind Minimum und Maximum angegeben.

Die Legende (Abbildung \ref{screenshot} \circled{5}) passt sich den Ansichtsoptionen an und zeigt für die Einfärbung nach Geschwindigkeit und Dichte die entsprechende Farbkodierung der Fußgänger an. Wenn das Gitternetz sichtbar ist, wird der Abstand der Gitternetzlinien in Metern angezeigt.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=\textwidth]{media/screenshot.png}
\caption{Screenshot des SumoViz3D-Interfaces}
\label{screenshot}
\end{center}
\end{figure}

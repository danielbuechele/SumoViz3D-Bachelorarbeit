
\subsection{Darstellung der Geometrie}
\label{geo}
Die geometrischen Objekte zur Darstellung der Umgebung enthalten in ihrer Datenstruktur die Beschreibung ihres Grundrisses in Form von x-y-Koordinaten, eine Höhenangabe, den Namen und ein Typen-Feld. Für die Darstellung maßgeblich entscheidend ist der Inhalt des Typen-Felds. Es entscheidet, welche Renderingroutine verwendet wird. Folgende Typen werden von SumoViz3D unterschieden: \verb+geometry+, \verb+obstacle+, \verb+wall+. Zudem gibt es noch eine vierte Renderingroutine für alle anderen Typen unter die vor allem \verb+source+, \verb+target+ und \verb+field+ fallen.

Die Berechnung der Geometrie erfolgt beim Laden der Simulation und muss nur einmalig ausgeführt werden. Dazu wird die Methode \verb+drawGeometry+ definiert. Wird die Geometrie während der Laufzeit verändert, wird diese Methode erneut aufgerufen (siehe Kapitel \ref{recallgeo}).
 
\subsubsection{Skalierung der Geometrie}

Die darzustellende Geometrie kann extrem unterschiedliche Dimensionen haben. Trotzdem soll nach dem Laden der Szene die Kamera so positioniert sein, dass ein Überblick über die gesamte Szene möglich ist.

\begin{wrapfigure}{r}{0.5\textwidth}
  \includegraphics[width=0.5\textwidth]{media/zfighting.png}
  \caption{Z-Fighting zwischen Grundebene und Feldern bei großer Kameradistanz}
  \label{fig:zfighter}
\end{wrapfigure}


Erster Ansatz zur Lösung war es, die Kameradistanz entsprechend der Größe der Szene mitzuskalieren. Jedoch trat hierbei \emph{Z-Fighting} auf. Ein bekanntes Problem aus dem 3D-Bereich, bei dem durch Rundungsfehler Fehler in der Darstellung auftreten. Bei einer hohen Distanz zwischen Kamera und Objekten ist der relative Abstand der Objekte zueinander sehr gering. Durch mangelnde Genauigkeit in der Speicherung der Tiefenwerte zweier Objekte kann nicht mehr entschieden werden, welches Objekt vor dem jeweils anderen liegt. Objekte die eigentlich verdeckt sein müssten, flimmern an manchen Stellen durch die Oberfläche hindurch (vgl. Abbildung \ref{fig:zfighter}).

Zur Lösung des Problems wird nun die Kameradistanz für jede Szene unverändert gelassen und die Geometrie- und Fußgängerobjekte entsprechend der Größe der Grundebene (\verb+geometrySize+) skaliert. Dazu wird ein Skalierungsfaktor \verb+globalScale+ wie folgt berechnet:
\begin{verbatim}
    globalScale = 50/((geometrySize.x+geometrySize.y)/2);
\end{verbatim}
Der Faktor $50$ wurde empirisch bestimmt. Jedes dargestellte Objekt wird mit dem Skalierungsfaktor multipliziert und entsprechend vergrößert oder verkleinert. Einige weitere Vorteile ergeben sich aus diesem Vorgehen: Die Anzahl und Position der Lichter müssen nicht an die Szenengröße angepasst werden um diese vollständig auszuleuchten, denn absolut gesehen hat jede Szene exakt die gleiche Größe. Selbiges gilt für die Steuerung der Kamera (vgl. Kapitel \ref{controls}) die nicht auf die Szenengröße angepasst werden muss.

\subsubsection{Darstellung der Grundebene und des Gitternetz}
In den Geometriedaten befindet sich immer ein Element vom Typ \verb+geometry+, das eine rechteckige Grundfläche definiert die alle Objekte enthält. Diese Fläche wird orthogonal zur y-Achse des WebGL-Koordinatensystems eingezeichnet und beginnt im Ursprung. Auf dieser Grundebene wird ein Gitternetz eingezeichnet, das zwei Zwecke erfüllt: Einerseits helfen die Linien, die auf den Fluchtpunkt zulaufen bei der Tiefenwahrnehmung. Andererseits lassen sich mit dem in der Legende angegebenen ``grid pitch'' die Größenverhältnisse besser beurteilen. Dieser Wert gibt den Abstand zweier benachbarter Gitternetzlinien in Metern an. Eine Maßstabangabe wie in Landkarten ist auf Grund der perspektivischen Abbildung nicht möglich.


\subsubsection{Darstellung von Objekten des Typ ``obstacle''}
Geometrie vom Typ \verb+obstacle+ sind bauliche Hindernisse wie Gebäude oder auch Bäume und Pflanzen. Diese müssen von den Fußgängern umgangen werden. Für die Darstellung dieser Hindernisse wird ein Polygon aus den x-y-Koordinaten erzeugt. Mit einer \verb+ExtrudeGeometry+ wird aus dem flachen Polygon dann ein dreidemensionales Objekt erzeugt. Hierfür wird die beim Objekt gespeicherte Höhenangabe benötigt.

Bäume und Pflanzen werden gesondert dargestellt. Die Erkennung davon erfolgt über den Namen des Objekts. Ein entsprechendes Objekt kann beispielsweise \verb+tree0+ benannt sein. Enthält also ein Objektname \verb+tree+ oder \verb+plant+ wird die Darstellung angepasst. Dazu sind in SumoViz3D externe Modelle eines Baums und eines Buschs hinterlegt. THREE.js bietet verschiedene Erweiterungen zum importieren von externen 3D-Modellen in unterschiedlichen Formaten. SumoViz3D verwendet den \verb+ColladaLoader+, der Modelle im \emph{COLLADA}-Format importieren kann. \emph{COLLADA (COLLAborative Design Activity)} ist ein offenes XML-Format für die Speicherung von Modellen, Texturen und ganzen Szenen. Das Format wird wie WebGL auch von der Khronos Group verwaltet und kann in vielen 3D-Programmen im- und exportiert werden.

Das Baum- bzw. Busch-Model wird mittels des Loaders aus der Datei geladen und geparst. Danach steht es als normales 3D-Objekt zur Verfügung und kann skaliert und positioniert werden. Um die Ladezeit gering zu halten, wurden die Modelle mit sehr wenigen Vertices angelegt und mit einfachen Texturen versehen. Die Dateigröße des Baum-Models mit Grafiktextur beträgt etwa 50 Kilobytes. Komplexere Modelle könnten mehrere Megabytes groß sein und das Nachladen über die Internetverbindung würde zu lange dauern.

%https://collada.org/mediawiki/index.php/COLLADA_-_Digital_Asset_and_FX_Exchange_Schema


\subsubsection{Darstellung von Objekten des Typ ``wall''}
Wände sind als Pfad definiert. Die einzelnen Koordinaten werden linear verbunden und ergeben so die Grundlinie der Wand. Um in der 3D-Darstellung realistischer zu wirken sollen die Wände auch noch eine Dicke erhalten. Dazu wird aus jeweils zwei benachbarten Pfadpunkten und den selben Punkten, die aber in der Höhe verschoben wurden, ein Rechteck gebildet. Die Höhe der Wand stammt dabei auch aus den importierten Ursprungsdaten. Dieses Rechteck wird wieder mit \verb+ExtrudeGeometry+ um die Dicke der Wand zu einem Quader ausgedehnt. Da eine Wand mehr als zwei Pfadpunkte haben kann, werden die entstandenen Quader dann wieder zu einem Objekt zusammen gefügt und angezeigt.


\subsubsection{Darstellung anderer Objekte}
Hat die Geometrie einen anderen Typ, so wird sie als flaches Polygon auf der Grundebene dargestellt. Alle Szenen haben mindestens ein Objekt vom Typ \verb+source+ das der Startpunkt der Fußgänger ist. Entsprechend exsistiert \verb+target+, welches das Ziel der Fußgänger darstellt. Pro Szene können auch mehrere Start- und Zielfelder vorhanden sein. Der Typ \verb+field+ wird ebenso dargestellt und markiert Bereiche, die beispielsweise besondere Auswirkungen wie Verlangsamung oder Beschleunigung auf die Fußgänger haben. Aber auch völlig unbekannte Geometrietypen können in diesem Fallback zumindest grundlegend angezeigt werden.


\subsubsection{Veränderung während der Laufzeit}
\label{settings}
Eigentlich ist die Geometrie während der gesamten Zeit unverändert und wird deshalb nur initial berechnet. SumoViz3D ermöglicht dem Betrachter zusätzlich das Erscheinungsbild der Szene anzupassen und so ein realistischere Darstellung zu erzeugen. Folgende Modifikationen an der Geometrie sind dem Benutzer während der Laufzeit möglich:

\textbf{Globale Modifikationen:}
\begin{itemize}
    \item Das Gitternetz der Grundebene lässt sich ein- und ausblenden.
    
    \item Die Textur der Grundebene kann verändert werden. Es steht eine Auswahl verschiedener Grafiktexturen, wie beispielsweise Wiese oder Erde, zur Verfügung.

    \item Es kann eine Grafiktextur für alle Wände ausgewählt werden. Hier steht ebenfalls eine Vorauswahl zur Verfügung.
\end{itemize}

\textbf{Objektbezogene Modifikationen:}
\begin{itemize}
    \item Einzelne Objekte der Szene lassen sich entfernen.

    \item Alle Objekte, außer Bäume und Büsche, lassen sich individuell einfärben.

    \item Objekte vom Typ \verb+obstacle+ lassen sich zu Bäumen oder Büschen konvertieren. Dazu wird vor den bestehenden Objektnamen der Prefix \verb+tree_+ oder \verb+plant_+ gesetzt. 
\end{itemize}
Globale Modifikationen können über das Einstellungsmenü in der Toolbar vorgenommen werden. Für objektbezogene Modifikationen muss ein entsprechendes Objekt mit einem Kontextklick ausgewählt werden. Um zu erkennen welches Objekt durch den Kontextklick ausgewählt wurde ist eine Berechnung nötig, welche die 2D-Koordinaten des JavaScript-Events \verb+contextmenu+ auf die 3D-Szene umgerechnet. Die x- und y-Koordinaten des Klicks werden in das WebGL-Koordinatensystem (vgl. Kapitel \ref{}) konvertiert und für die z-Achse wird ein fester Wert verwendet. Dann wird ein Strahl ausgehend von der Kameraposition in Richtung des Klickpunkts berechnet und die durchquerten Objekte ermittelt. Das erste dieser Objekte ist das vom Benutzer ausgewählte, da die später durchkreuzten Objekte verdeckt und damit für den Nutzer nicht sichtbar sind.


\subsubsection{Speichern der Einstellungen}
\label{recallgeo}

Die Modifikationen, die durch den Benutzer vergenommen wurden, sollen persistent gespeichert werden. Zu diesem Zweck wird die \emph{WebStorage}-API, die mit HTML5 spezifiziert wurde, verwendet. Es handelt sich dabei um lokalen Speicher in Form von Key-/Value-Paaren. Einschränkend ist hierbei, dass nur Strings gespeichert werden können. Um andere Datentypen zu speichern, können diese beispielsweise im JSON-Format hinterlegt werden. Für die Größe des Speichers schlägt das W3C 5 Megabytes vor. Zugriff auf den Speicher erfolgt über das \verb+localStorage+-Objekt mittels der Methoden \verb+setValue(key, value)+ und \verb+getValue(key)+ oder alternativ über die Punktschreibweise \verb+localStorage.key+ oder assoziative Arrays \verb+localStorage["key"]+. Änderungen im Speicher müssen nicht mehr explizit gespeichert werden und sind über die Session hinaus beliebig lange verfügbar. Mit \verb+localStorage.clear()+ lässt sich der Inhalt des Speichers löschen. 

Alle in Kapitel \ref{settings} vorgenommen Änderungen werden pro Simulation im lokalen Speicher abgelegt. Die vorgenommenen Änderungen werden sofort gespeichert und sind nicht für andere Nutzer sichtbar. Nach dem Laden der Szene wird geprüft ob für diese Simulationsdaten bereits Einstellungen hinterlegt wurden und diese gegebenenfalls angewendet.

Zum Ablegen der globalen Modifikationen wird das Schlüsselformat \verb+animationName_setting+ verwendet. Zudem werden unter dem Schlüssel \verb+animationName_objectSettings+ die objektbezogenen Anpassungen gespeichert. Hier wird ein JSON-Array erwartet, das an jeder Array-Position die Anpassungen für das jeweilige Objekt oder den Wert \verb+null+ hat.



%https://developer.mozilla.org/en-US/docs/DOM/Storage?redirectlocale=en-US&redirectslug=DOM%3AStorage 
% http://www.w3.org/TR/webstorage/
% http://diveintohtml5.info/storage.html


\subsection{Animationen in JavaScript}
\label{raf}
Um Animationen in JavaScript auszuführen wurden die Funktionen \verb+setTimeout(function,delay)+ oder \verb+setInterval(function,interval)+ verwendet. Diese rufen in einem festgelegten Rhythmus eine Funktion auf, die inkrementell die Animation ausführt. Während \verb+setInterval+ nur einmalig aufgerufen wird und dann von alleine die Funktion im angegebenen Intervall aufruft, muss \verb+setTimeout+ nach der Ausführung des Animationsschritts erneut rekursiv aufgerufen werden. Jedoch gibt es einige Nachteile bei der Verwendung dieser Methoden: Die Wiederholrate wird fest vorgegeben, unabhängig von der Leistung des Rechners. Ist die Ausführung zum angegebenen Zeitpunkt nicht möglich, da gerade eine andere Berechnung ausgeführt wird, wird die Funktion in eine Warteschlange gestellt. In der Warteschlange wird nur ein Aufruf jeder Funktion gespeichert, alle weiteren werden ignoriert und nicht ausgeführt. Üblicherweise liegt die Wiederholrate eines Bildschirms bei $60Hz$. Daher lohnt es sich nicht die Animations-Schleife öfter auszuführen. Damit ergibt sich eine Intervallzeit von ca. $17ms$.

%http://www.nczonline.net/blog/2011/05/03/better-javascript-animations-with-requestanimationframe/
%http://ejohn.org/blog/how-javascript-timers-work/


Ein grundlegendes Problem bei der beschriebenen Vorgehensweise ist, dass für den Browser nicht erkennbar ist, dass es sich bei der aufgerufenen Funktion um die Ausführung einer Animation handelt und deshalb keine spezifischen Optimierungen möglich sind. Mozilla entwickelte den Funktionsaufruf \verb+requestAnimationFrame+. Da der Browser weiß, dass es sich dabei um die Ausführung von Animationen handelt, kann er beispielsweise parallel ablaufende Aufrufe in einem repaint-Zyklus zusammenfassen. Wie bei der \verb+setTimeout+-Methode muss die Funktion nach dem Ablaufen des Animationsschritts rekursiv aufgerufen werden, wodurch die Animation mit maximaler Wiederholrate abläuft. Der Browser kann die Ausführung komplett stoppen, wenn das Fenster im Hintergrund und nicht für den User sichtbar ist. Das spart CPU-Ressourcen und senkt so den Stromverbrauch.

%http://paulirish.com/2011/requestanimationframe-for-smart-animating/
%https://developer.mozilla.org/en-US/docs/DOM/window.requestAnimationFrame

Die Standardisierung vom W3C ist noch nicht final, weshalb einige Browser-Hersteller die Funktion mit einem so genannten Vendor-Prefix implementieren. Für den Einsatz in Firefox wird beispielsweise \verb+mozRequestAnimationFrame+ verwendet. Deshalb setzt SumoViz3D ein \emph{Polyfill} ein, das beim Aufruf von \verb+requestAnimationFrame+ die im jeweiligen Browser verfügbare Methode verwendet. Für Browser ohne Unterstützung von \verb+requestAnimationFrame+ gibt ein Fallback mit der Verwendung von \verb+setTimeout+. Dieses Fallback versucht die Intervallzeit zu optimieren, um eine maximale Framerate zu erreichen. Dazu wird die Ausführungszeit der Methode berechnet und die Intervallzeit entsprechend gestzt.

%http://www.w3.org/TR/animation-timing/#requestAnimationFrame

Die Wiederholrate der Animation ist abhängig von der Geschwindigkeit des Rechners. Der Ablauf der Visualisierung muss aber unabhängig von der Rechneleistung sein, damit auf schnellen Rechnern nicht alle Simulationsschritte innerhalb weniger Sekunden ablaufen. Deshalb wird das Aktualisieren der Fußgängerkoordinaten und deren Einfärbung von der Animationsschleife entkoppelt und mit einer \verb+setInterval+-Methode regelmäßig ausgeführt. Innerhalb der Animationsschleife findet dann das Neuzeichnen des canvas-Elements und das Aktualisieren der Kameraposition (vgl. Kapitel \ref{controls}) statt. Zusätzlich wird noch das THREE.js-Stats-Objekt zum Auslesen der Framerate aktualisiert.

\begin{lstlisting}[caption=Animationen mittels requestAnimationFrame]
setInterval(updatePedestrians, 1000/5);  
animate();                               //initialer Aufruf

function animate() {
    requestAnimationFrame( animate );    //rekursiver Aufruf
    controls.update();                   //Aktualisieren der Kameraposition
    renderer.render( scene, camera );    //Neuzeichnen des canvas-Elements
    stats.update();                      //Messen der Geschwindigkeit
}
\end{lstlisting}